/* SiteswapParserTokenManager.java */ /* Generated By:JavaCC: Do not edit this line. SiteswapParserTokenManager.java */
package jugglinglab.notation.ssparser

import java.io.IOException
import java.io.PrintStream

/** Token Manager.  */
class SiteswapParserTokenManager : SiteswapParserConstants {
    /** Debug output.  */
    var debugStream: PrintStream? = System.out

    /** Set debug output.  */
    fun setDebugStream(ds: PrintStream?) {
        debugStream = ds
    }

    private fun jjStopStringLiteralDfa_0(pos: Int, active0: Long): Int {
        when (pos) {
            else -> return -1
        }
    }

    private fun jjStartNfa_0(pos: Int, active0: Long): Int {
        return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1)
    }

    private fun jjStopAtPos(pos: Int, kind: Int): Int {
        jjmatchedKind = kind
        jjmatchedPos = pos
        return pos + 1
    }

    private fun jjMoveStringLiteralDfa0_0(): Int {
        when (curChar) {
            33 -> return jjStopAtPos(0, 12)
            40 -> return jjStopAtPos(0, 9)
            41 -> return jjStopAtPos(0, 11)
            42 -> return jjStopAtPos(0, 8)
            44 -> return jjStopAtPos(0, 13)
            47 -> return jjStopAtPos(0, 20)
            60 -> return jjStopAtPos(0, 23)
            62 -> return jjStopAtPos(0, 25)
            63 -> return jjStopAtPos(0, 26)
            76 -> return jjStopAtPos(0, 22)
            82 -> return jjStopAtPos(0, 21)
            91 -> return jjStopAtPos(0, 14)
            93 -> return jjStopAtPos(0, 15)
            94 -> return jjStopAtPos(0, 10)
            112 -> return jjStopAtPos(0, 16)
            120 -> return jjStopAtPos(0, 17)
            123 -> return jjStopAtPos(0, 18)
            124 -> return jjStopAtPos(0, 24)
            125 -> return jjStopAtPos(0, 19)
            else -> return jjMoveNfa_0(0, 0)
        }
    }

    private fun jjMoveNfa_0(startState: Int, curPos: Int): Int {
        var curPos = curPos
        var startsAt = 0
        jjnewStateCnt = 4
        var i = 1
        jjstateSet[0] = startState
        var kind = 0x7fffffff
        while (true) {
            if (++jjround == 0x7fffffff) ReInitRounds()
            if (curChar < 64) {
                val l = 1L shl curChar
                do {
                    when (jjstateSet[--i]) {
                        0 -> if ((0x3ff000000000000L and l) != 0L) {
                            if (kind > 4) kind = 4
                        } else if (curChar == 32) {
                            if (kind > 7) kind = 7
                            run { jjCheckNAdd(3) }
                        }

                        3 -> {
                            if (curChar != 32) break
                            kind = 7
                            run { jjCheckNAdd(3) }
                        }

                        else -> {}
                    }
                } while (i != startsAt)
            } else if (curChar < 128) {
                val l = 1L shl (curChar and 63)
                do {
                    when (jjstateSet[--i]) {
                        0 -> if ((0x7fbeffeL and l) != 0L) {
                            if (kind > 6) kind = 6
                            run { jjCheckNAdd(2) }
                        } else if ((0x6fefffe00000000L and l) != 0L) {
                            if (kind > 5) kind = 5
                        }

                        1 -> if ((0x6fefffe00000000L and l) != 0L) kind = 5
                        2 -> {
                            if ((0x7fbeffeL and l) == 0L) break
                            kind = 6
                            run { jjCheckNAdd(2) }
                        }

                        else -> {}
                    }
                } while (i != startsAt)
            } else {
                val i2 = (curChar and 0xff) shr 6
                val l2 = 1L shl (curChar and 63)
                do {
                    when (jjstateSet[--i]) {
                        else -> {}
                    }
                } while (i != startsAt)
            }
            if (kind != 0x7fffffff) {
                jjmatchedKind = kind
                jjmatchedPos = curPos
                kind = 0x7fffffff
            }
            ++curPos
            if ((jjnewStateCnt.also { i = it }) == ((4 - (startsAt.also { jjnewStateCnt = it })).also {
                    startsAt = it
                })) return curPos
            try {
                curChar = input_stream!!.readChar().code
            } catch (e: IOException) {
                return curPos
            }
        }
    }

    protected fun jjFillToken(): Token {
        val t: Token
        val curTokenImage: String
        val beginLine: Int
        val endLine: Int
        val beginColumn: Int
        val endColumn: Int
        val im: String? = jjstrLiteralImages[jjmatchedKind]
        curTokenImage = if (im == null) input_stream!!.GetImage() else im
        beginLine = input_stream!!.beginLine
        beginColumn = input_stream!!.beginColumn
        endLine = input_stream!!.endLine
        endColumn = input_stream!!.endColumn
        t = Token.newToken(jjmatchedKind, curTokenImage)

        t.beginLine = beginLine
        t.endLine = endLine
        t.beginColumn = beginColumn
        t.endColumn = endColumn

        return t
    }

    var curLexState: Int = 0
    var defaultLexState: Int = 0
    var jjnewStateCnt: Int = 0
    var jjround: Int = 0
    var jjmatchedPos: Int = 0
    var jjmatchedKind: Int = 0

    val nextToken: Token?
        /** Get the next Token.  */
        get() {
            val matchedToken: Token?
            var curPos = 0

            EOFLoop@ while (true) {
                try {
                    curChar = input_stream!!.BeginToken().code
                } catch (e: Exception) {
                    jjmatchedKind = 0
                    jjmatchedPos = -1
                    matchedToken = jjFillToken()
                    return matchedToken
                }

                try {
                    input_stream!!.backup(0)
                    while (curChar <= 13 && (0x2600L and (1L shl curChar)) != 0L) curChar =
                        input_stream!!.BeginToken().code
                } catch (e1: IOException) {
                    continue@EOFLoop
                }
                jjmatchedKind = 0x7fffffff
                jjmatchedPos = 0
                curPos = jjMoveStringLiteralDfa0_0()
                if (jjmatchedKind != 0x7fffffff) {
                    if (jjmatchedPos + 1 < curPos) input_stream!!.backup(curPos - jjmatchedPos - 1)
                    if ((jjtoToken[jjmatchedKind shr 6] and (1L shl (jjmatchedKind and 63))) != 0L) {
                        matchedToken = jjFillToken()
                        return matchedToken
                    } else {
                        continue@EOFLoop
                    }
                }
                var error_line = input_stream!!.endLine
                var error_column = input_stream!!.endColumn
                var error_after: String? = null
                var EOFSeen = false
                try {
                    input_stream!!.readChar()
                    input_stream!!.backup(1)
                } catch (e1: IOException) {
                    EOFSeen = true
                    error_after = if (curPos <= 1) "" else input_stream!!.GetImage()
                    if (curChar == '\n'.code || curChar == '\r'.code) {
                        error_line++
                        error_column = 0
                    } else error_column++
                }
                if (!EOFSeen) {
                    input_stream!!.backup(1)
                    error_after = if (curPos <= 1) "" else input_stream!!.GetImage()
                }
                throw TokenMgrError(
                    EOFSeen,
                    curLexState,
                    error_line,
                    error_column,
                    error_after,
                    curChar,
                    TokenMgrError.LEXICAL_ERROR
                )
            }
        }

    fun SkipLexicalActions(matchedToken: Token?) {
        when (jjmatchedKind) {
            else -> {}
        }
    }

    fun MoreLexicalActions() {
        jjimageLen += ((jjmatchedPos + 1).also { lengthOfMatch = it })
        when (jjmatchedKind) {
            else -> {}
        }
    }

    fun TokenLexicalActions(matchedToken: Token?) {
        when (jjmatchedKind) {
            else -> {}
        }
    }

    private fun jjCheckNAdd(state: Int) {
        if (jjrounds[state] != jjround) {
            jjstateSet[jjnewStateCnt++] = state
            jjrounds[state] = jjround
        }
    }

    private fun jjAddStates(start: Int, end: Int) {
        var start = start
        do {
            jjstateSet[jjnewStateCnt++] = jjnextStates[start]
        } while (start++ != end)
    }

    private fun jjCheckNAddTwoStates(state1: Int, state2: Int) {
        jjCheckNAdd(state1)
        jjCheckNAdd(state2)
    }

    /** Constructor.  */
    constructor(stream: SimpleCharStream) {
        if (SimpleCharStream.staticFlag) throw Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.")

        input_stream = stream
    }

    /** Constructor.  */
    constructor(stream: SimpleCharStream, lexState: Int) {
        ReInit(stream)
        SwitchTo(lexState)
    }

    /** Reinitialise parser.  */
    fun ReInit(stream: SimpleCharStream) {
        jjnewStateCnt =
            0
        jjmatchedPos = jjnewStateCnt
        curLexState = defaultLexState
        input_stream = stream
        ReInitRounds()
    }

    private fun ReInitRounds() {
        var i: Int
        jjround = -0x7fffffff
        i = 4
        while (i-- > 0) {
            jjrounds[i] = -0x80000000
        }
    }

    /** Reinitialise parser.  */
    fun ReInit(stream: SimpleCharStream, lexState: Int) {
        ReInit(stream)
        SwitchTo(lexState)
    }

    /** Switch to specified lex state.  */
    fun SwitchTo(lexState: Int) {
        if (lexState >= 1 || lexState < 0) throw TokenMgrError(
            "Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.",
            TokenMgrError.INVALID_LEXICAL_STATE
        )
        else curLexState = lexState
    }


    protected var input_stream: SimpleCharStream? = null

    private val jjrounds = IntArray(4)
    private val jjstateSet = IntArray(2 * 4)
    private val jjimage = StringBuilder()
    private val image: StringBuilder = jjimage
    private var jjimageLen = 0
    private var lengthOfMatch = 0
    protected var curChar: Int = 0

    companion object {
        /** Token literal values.  */
        val jjstrLiteralImages: Array<String?> = arrayOf<String?>(
            "",
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            "\u002a",
            "\u0028",
            "\u005e",
            "\u0029",
            "\u0021",
            "\u002c",
            "\u005b",
            "\u005d",
            "\u0070",
            "\u0078",
            "\u007b",
            "\u007d",
            "\u002f",
            "\u0052",
            "\u004c",
            "\u003c",
            "\u007c",
            "\u003e",
            "\u003f",
        )
        val jjnextStates: IntArray = intArrayOf(
            0
        )

        /** Lexer state names.  */
        val lexStateNames: Array<String?> = arrayOf<String?>(
            "DEFAULT",
        )

        /** Lex State array.  */
        val jjnewLexState: IntArray = intArrayOf(
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
            -1, -1,
        )
        val jjtoToken: LongArray = longArrayOf(
            0x7fffff1L,
        )
        val jjtoSkip: LongArray = longArrayOf(
            0xeL,
        )
        val jjtoSpecial: LongArray = longArrayOf(
            0x0L,
        )
        val jjtoMore: LongArray = longArrayOf(
            0x0L,
        )
    }
}
