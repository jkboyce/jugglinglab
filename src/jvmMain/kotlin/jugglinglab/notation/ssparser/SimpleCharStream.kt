/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 7.0 */ /* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package jugglinglab.notation.ssparser

import java.io.*

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
class SimpleCharStream
@JvmOverloads constructor(
    protected var inputStream: Reader, startline: Int = 1,
    startcolumn: Int = 1, buffersize: Int = 4096
) {
    var bufsize: Int
    var available: Int
    var tokenBegin: Int = 0

    /** Position in buffer.  */
    var bufpos: Int = -1
    protected var bufline: IntArray?
    protected var bufcolumn: IntArray?

    protected var column: Int = 0
    protected var line: Int = 1

    protected var prevCharIsCR: Boolean = false
    protected var prevCharIsLF: Boolean = false

    protected var buffer: CharArray?
    protected var maxNextCharInd: Int = 0
    protected var inBuf: Int = 0
    var tabSize: Int = 1
    var trackLineColumn: Boolean = true


    protected fun ExpandBuff(wrapAround: Boolean) {
        val newbuffer = CharArray(bufsize + 2048)
        val newbufline: IntArray? = IntArray(bufsize + 2048)
        val newbufcolumn: IntArray? = IntArray(bufsize + 2048)

        try {
            if (wrapAround) {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin)
                System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos)
                buffer = newbuffer

                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin)
                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos)
                bufline = newbufline

                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin)
                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos)
                bufcolumn = newbufcolumn

                maxNextCharInd = (bufsize - tokenBegin.let { bufpos += it; bufpos })
            } else {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin)
                buffer = newbuffer

                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin)
                bufline = newbufline

                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin)
                bufcolumn = newbufcolumn

                maxNextCharInd = (tokenBegin.let { bufpos -= it; bufpos })
            }
        } catch (t: Throwable) {
            throw Error(t.message)
        }


        bufsize += 2048
        available = bufsize
        tokenBegin = 0
    }

    @Throws(IOException::class)
    protected fun FillBuff() {
        if (maxNextCharInd == available) {
            if (available == bufsize) {
                if (tokenBegin > 2048) {
                    maxNextCharInd = 0
                    bufpos = maxNextCharInd
                    available = tokenBegin
                } else if (tokenBegin < 0) {
                    maxNextCharInd = 0
                    bufpos = maxNextCharInd
                } else ExpandBuff(false)
            } else if (available > tokenBegin) available = bufsize
            else if ((tokenBegin - available) < 2048) ExpandBuff(true)
            else available = tokenBegin
        }

        val i: Int
        try {
            if ((inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd).also { i = it }) == -1) {
                inputStream.close()
                throw IOException()
            } else maxNextCharInd += i
            return
        } catch (e: IOException) {
            --bufpos
            backup(0)
            if (tokenBegin == -1) tokenBegin = bufpos
            throw e
        }
    }

    /** Start.  */
    @Throws(IOException::class)
    fun BeginToken(): Char {
        tokenBegin = -1
        val c = readChar()
        tokenBegin = bufpos

        return c
    }

    protected fun UpdateLineColumn(c: Char) {
        column++

        if (prevCharIsLF) {
            prevCharIsLF = false
            line += (1.also { column = it })
        } else if (prevCharIsCR) {
            prevCharIsCR = false
            if (c == '\n') {
                prevCharIsLF = true
            } else line += (1.also { column = it })
        }

        when (c) {
            '\r' -> prevCharIsCR = true
            '\n' -> prevCharIsLF = true
            '\t' -> {
                column--
                column += (tabSize - (column % tabSize))
            }

            else -> {}
        }

        bufline!![bufpos] = line
        bufcolumn!![bufpos] = column
    }

    /** Read a character.  */
    @Throws(IOException::class)
    fun readChar(): Char {
        if (inBuf > 0) {
            --inBuf

            if (++bufpos == bufsize) bufpos = 0

            return buffer!![bufpos]
        }

        if (++bufpos >= maxNextCharInd) FillBuff()

        val c = buffer!![bufpos]

        UpdateLineColumn(c)
        return c
    }

    val endColumn: Int
        /** Get token end column number.  */
        get() = bufcolumn!![bufpos]

    val endLine: Int
        /** Get token end line number.  */
        get() = bufline!![bufpos]

    val beginColumn: Int
        /** Get token beginning column number.  */
        get() = bufcolumn!![tokenBegin]

    val beginLine: Int
        /** Get token beginning line number.  */
        get() = bufline!![tokenBegin]

    /** Backup a number of characters.  */
    fun backup(amount: Int) {
        inBuf += amount
        if ((amount.let { bufpos -= it; bufpos }) < 0) bufpos += bufsize
    }

    /** Constructor.  */
    /** Constructor.  */
    /** Constructor.  */
    init {
        line = startline
        column = startcolumn - 1

        bufsize = buffersize
        available = bufsize
        buffer = CharArray(buffersize)
        bufline = IntArray(buffersize)
        bufcolumn = IntArray(buffersize)
    }

    /** Reinitialise.  */
    /** Reinitialise.  */
    /** Reinitialise.  */
    @JvmOverloads
    fun ReInit(
        dstream: Reader, startline: Int = 1,
        startcolumn: Int = 1, buffersize: Int = 4096
    ) {
        inputStream = dstream
        line = startline
        column = startcolumn - 1

        if (buffer == null || buffersize != buffer!!.size) {
            bufsize = buffersize
            available = bufsize
            buffer = CharArray(buffersize)
            bufline = IntArray(buffersize)
            bufcolumn = IntArray(buffersize)
        }
        prevCharIsCR = false
        prevCharIsLF = prevCharIsCR
        maxNextCharInd = 0
        inBuf = maxNextCharInd
        tokenBegin = inBuf
        bufpos = -1
    }

    /** Constructor.  */
    /** Constructor.  */
    /** Constructor.  */
    @JvmOverloads
    constructor(
        dstream: InputStream, encoding: String?, startline: Int = 1,
        startcolumn: Int = 1, buffersize: Int = 4096
    ) : this(
        if (encoding == null) InputStreamReader(dstream) else InputStreamReader(dstream, encoding),
        startline,
        startcolumn,
        buffersize
    )

    /** Constructor.  */
    /** Constructor.  */
    /** Constructor.  */
    @JvmOverloads
    constructor(
        dstream: InputStream, startline: Int = 1,
        startcolumn: Int = 1, buffersize: Int = 4096
    ) : this(InputStreamReader(dstream), startline, startcolumn, buffersize)

    /** Reinitialise.  */
    /** Reinitialise.  */
    /** Reinitialise.  */
    @JvmOverloads
    @Throws(UnsupportedEncodingException::class)
    fun ReInit(
        dstream: InputStream, encoding: String?, startline: Int = 1,
        startcolumn: Int = 1, buffersize: Int = 4096
    ) {
        ReInit(
            if (encoding == null) InputStreamReader(dstream) else InputStreamReader(dstream, encoding),
            startline,
            startcolumn,
            buffersize
        )
    }
    /** Reinitialise.  */
    /** Reinitialise.  */
    /** Reinitialise.  */
    @JvmOverloads
    fun ReInit(
        dstream: InputStream, startline: Int = 1,
        startcolumn: Int = 1, buffersize: Int = 4096
    ) {
        ReInit(InputStreamReader(dstream), startline, startcolumn, buffersize)
    }

    /** Get token literal value.  */
    fun GetImage(): String {
        if (bufpos >= tokenBegin) return kotlin.text.String(buffer!!, tokenBegin, bufpos - tokenBegin + 1)
        else return kotlin.text.String(buffer!!, tokenBegin, bufsize - tokenBegin) + kotlin.text.String(
            buffer!!,
            0,
            bufpos + 1
        )
    }

    /** Get the suffix.  */
    fun GetSuffix(len: Int): CharArray {
        val ret = CharArray(len)

        if ((bufpos + 1) >= len) System.arraycopy(buffer, bufpos - len + 1, ret, 0, len)
        else {
            System.arraycopy(
                buffer, bufsize - (len - bufpos - 1), ret, 0,
                len - bufpos - 1
            )
            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1)
        }

        return ret
    }

    /** Reset buffer when finished.  */
    fun Done() {
        buffer = null
        bufline = null
        bufcolumn = null
    }

    /**
     * Method to adjust line and column numbers for the start of a token.
     */
    fun adjustBeginLineColumn(newLine: Int, newCol: Int) {
        var newLine = newLine
        var start = tokenBegin
        val len: Int

        if (bufpos >= tokenBegin) {
            len = bufpos - tokenBegin + inBuf + 1
        } else {
            len = bufsize - tokenBegin + bufpos + 1 + inBuf
        }

        var i = 0
        var j = 0
        var k = 0
        var nextColDiff = 0
        var columnDiff = 0

        while (i < len && bufline!![(start % bufsize).also { j = it }] == bufline!![(++start % bufsize).also {
                k = it
            }]) {
            bufline!![j] = newLine
            nextColDiff = columnDiff + bufcolumn!![k] - bufcolumn!![j]
            bufcolumn!![j] = newCol + columnDiff
            columnDiff = nextColDiff
            i++
        }

        if (i < len) {
            bufline!![j] = newLine++
            bufcolumn!![j] = newCol + columnDiff

            while (i++ < len) {
                if (bufline!![(start % bufsize).also { j = it }] != bufline!![++start % bufsize]) bufline!![j] =
                    newLine++
                else bufline!![j] = newLine
            }
        }

        line = bufline!![j]
        column = bufcolumn!![j]
    }

    companion object {
        /** Whether parser is static.  */
        const val staticFlag: Boolean = false
    }
} /* JavaCC - OriginalChecksum=d4a285d0a5ab7b83a8ba786b61a9de36 (do not edit this line) */
