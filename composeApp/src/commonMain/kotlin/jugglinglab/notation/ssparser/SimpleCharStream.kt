/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 7.0 */ /* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package jugglinglab.notation.ssparser

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
class SimpleCharStream
@JvmOverloads constructor(
    private var input: String,
    startline: Int = 1,
    startcolumn: Int = 1
) {
    private var bufsize: Int = input.length
    private var tokenBegin: Int = 0

    /** Position in buffer.  */
    var bufpos: Int = -1
    protected var bufline: IntArray?
    protected var bufcolumn: IntArray?

    protected var column: Int = 0
    protected var line: Int = 1

    protected var prevCharIsCR: Boolean = false
    protected var prevCharIsLF: Boolean = false

    private var buffer: CharArray = input.toCharArray()
    private var maxNextCharInd: Int = input.length
    protected var inBuf: Int = 0
    var tabSize: Int = 1
    var trackLineColumn: Boolean = true

    /** Since we read from a string, the whole buffer is filled once. */
    private fun FillBuff(): Nothing = throw Error("FillBuff() called when stream is already full")

    /** Start.  */
    fun BeginToken(): Char {
        tokenBegin = -1
        val c = readChar()
        tokenBegin = bufpos
        return c
    }

    protected fun UpdateLineColumn(c: Char) {
        column++

        when (c) {
            '\n' -> {
                if (prevCharIsCR) { // Handle CRLF
                    prevCharIsCR = false
                } else {
                    line++
                    column = 1
                }
            }
            '\r' -> {
                line++
                column = 1
                prevCharIsCR = true
            }
            '\t' -> {
                column--
                column += (tabSize - (column % tabSize))
            }
            else -> {
                prevCharIsCR = false
            }
        }

        bufline!![bufpos] = line
        bufcolumn!![bufpos] = column
    }

    /** Read a character.  */
    fun readChar(): Char {
        if (inBuf > 0) {
            --inBuf
            if (++bufpos == bufsize) bufpos = 0
            return buffer[bufpos]
        }

        // Check if we are at the end of the buffer *before* reading.
        if (bufpos + 1 >= maxNextCharInd) {
            // We are at the end. Don't advance bufpos past the end.
            return '\u0000' // EOF
        }

        bufpos++
        val c = buffer[bufpos]

        UpdateLineColumn(c)
        return c
    }

    val endColumn: Int
        /** Get token end column number.  */
        get() = bufcolumn!![bufpos]

    val endLine: Int
        /** Get token end line number.  */
        get() = bufline!![bufpos]

    val beginColumn: Int
        /** Get token beginning column number.  */
        get() = bufcolumn!![tokenBegin]

    val beginLine: Int
        /** Get token beginning line number.  */
        get() = bufline!![tokenBegin]

    /** Backup a number of characters.  */
    fun backup(amount: Int) {
        inBuf += amount
        bufpos -= amount
        if (bufpos < 0) bufpos += bufsize
    }

    /** Constructor.  */
    init {
        line = startline
        column = startcolumn - 1

        bufline = IntArray(bufsize)
        bufcolumn = IntArray(bufsize)
    }

    /** Reinitialise.  */
    @JvmOverloads
    fun ReInit(
        input: String,
        startline: Int = 1,
        startcolumn: Int = 1
    ) {
        this.input = input
        this.buffer = input.toCharArray()
        line = startline
        column = startcolumn - 1

        if (bufline == null || bufsize != this.input.length) {
            bufsize = this.input.length
            bufline = IntArray(bufsize)
            bufcolumn = IntArray(bufsize)
        }
        prevCharIsCR = false
        prevCharIsLF = prevCharIsCR
        maxNextCharInd = input.length
        inBuf = 0
        tokenBegin = 0
        bufpos = -1
    }

    /** Get token literal value.  */
    fun GetImage(): String = if (bufpos >= tokenBegin) {
        String(buffer, tokenBegin, bufpos - tokenBegin + 1)
    } else {
        String(buffer, tokenBegin, bufsize - tokenBegin) + String(buffer, 0, bufpos + 1)
    }

    /** Get the suffix.  */
    fun GetSuffix(len: Int): CharArray {
        val ret = CharArray(len)

        if ((bufpos + 1) >= len) buffer.copyInto(ret, 0, bufpos - len + 1, bufpos + 1)
        else {
            buffer.copyInto(
                ret, 0, bufsize - (len - bufpos - 1),
                bufsize
            )
            buffer.copyInto(ret, bufsize - (bufsize - (len - bufpos - 1)), 0, bufpos + 1)
        }

        return ret
    }

    /** Reset buffer when finished.  */
    fun Done() {
        // buffer is now backed by the input string, no need to null out
        bufline = null
        bufcolumn = null
    }

    /**
     * Method to adjust line and column numbers for the start of a token.
     */
    fun adjustBeginLineColumn(newLine: Int, newCol: Int) {
        var newLine = newLine
        var start = tokenBegin
        val len: Int

        if (bufpos >= tokenBegin) {
            len = bufpos - tokenBegin + inBuf + 1
        } else {
            len = bufsize - tokenBegin + bufpos + 1 + inBuf
        }

        var i = 0
        var j = 0
        var k = 0
        var nextColDiff = 0
        var columnDiff = 0

        while (i < len && bufline!![(start % bufsize).also { j = it }] == bufline!![(++start % bufsize).also {
                k = it
            }]) {
            bufline!![j] = newLine
            nextColDiff = columnDiff + bufcolumn!![k] - bufcolumn!![j]
            bufcolumn!![j] = newCol + columnDiff
            columnDiff = nextColDiff
            i++
        }

        if (i < len) {
            bufline!![j] = newLine++
            bufcolumn!![j] = newCol + columnDiff

            while (i++ < len) {
                if (bufline!![(start % bufsize).also { j = it }] != bufline!![++start % bufsize]) bufline!![j] =
                    newLine++
                else bufline!![j] = newLine
            }
        }

        line = bufline!![j]
        column = bufcolumn!![j]
    }

    companion object {
        /** Whether parser is static.  */
        const val staticFlag: Boolean = false
    }
} /* JavaCC - OriginalChecksum=d4a285d0a5ab7b83a8ba786b61a9de36 (do not edit this line) */
